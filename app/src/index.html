<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AI Assistant</title>

    <!--
      Content Security Policy (dev-friendly):
      - allow inline <script> so we can keep this file single-file during dev
      - allow fetch() to our local FastAPI worker
    -->
    <meta http-equiv="Content-Security-Policy"
          content="
            default-src 'self';
            script-src 'self' 'unsafe-inline';
            connect-src 'self' http://127.0.0.1:8000;
            style-src 'self' 'unsafe-inline';
            img-src 'self' data:;
          ">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script>
      (function(){
        try{
          var storageKey = 'ui.theme';
          var stored = window.localStorage ? localStorage.getItem(storageKey) : null;
          var prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
          var theme = stored || (prefersDark ? 'dark' : 'light');
          document.documentElement.setAttribute('data-theme', theme);
        }catch(err){
          document.documentElement.setAttribute('data-theme', 'dark');
        }
      })();
    </script>

    <!--
      Minimal design system (dark by default; user toggle switches data-theme)
      Keep all styles here so this file is copy-paste friendly.
    -->
    <style>
      :root{
        color-scheme: dark;
        --bg: #0b0c10;
        --panel: #111218;
        --panel-2:#0e1015;
        --muted:#a9b1bb;
        --text:#e8ecf1;
        --brand:#6ee7ff;
        --brand-2:#3fb4ff;
        --ok:#26a269;
        --bad:#c01c28;
        --border: rgba(255,255,255,0.08);
        --shadow: 0 8px 24px rgba(0,0,0,0.35);
        --radius: 14px;
        --field-bg:#161b24;
        --field-text:#e8ecf1;
      }
      :root[data-theme="dark"]{
        color-scheme: dark;
        --bg: #0b0c10;
        --panel: #111218;
        --panel-2:#0e1015;
        --muted:#a9b1bb;
        --text:#e8ecf1;
        --brand:#6ee7ff;
        --brand-2:#3fb4ff;
        --ok:#26a269;
        --bad:#c01c28;
        --border: rgba(255,255,255,0.08);
        --shadow: 0 8px 24px rgba(0,0,0,0.35);
        --radius: 14px;
        --field-bg:#161b24;
        --field-text:#e8ecf1;
      }
      :root[data-theme="light"]{
        color-scheme: light;
        --bg:#f6f8fb;
        --panel:#ffffff;
        --panel-2:#fdfefe;
        --muted:#54606e;
        --text:#10131a;
        --brand:#0ea5e9;
        --brand-2:#2563eb;
        --ok:#15803d;
        --bad:#b91c1c;
        --border: rgba(0,0,0,0.08);
        --shadow: 0 8px 24px rgba(0,0,0,0.08);
        --field-bg:#ffffff;
        --field-text:#10131a;
      }

      *{box-sizing:border-box}
      html,body{height:100%}
      body{
        margin:0; padding:24px;
        background: radial-gradient(1200px 800px at 10% -10%, rgba(110,231,255,0.08), transparent 40%),
                    radial-gradient(900px 600px at 110% 10%, rgba(63,180,255,0.08), transparent 40%),
                    var(--bg);
        color:var(--text);
        font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
      }

      /* Layout grid */
      .container{ max-width: 1100px; margin: 0 auto; display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      header{ grid-column: 1 / -1; display:flex; align-items:center; justify-content:space-between; margin-bottom: 8px; }
      .brand{ display:flex; align-items:center; gap:12px; letter-spacing:0.2px; }
      .logo{
        width:36px; height:36px; border-radius:10px;
        background: conic-gradient(from 220deg, var(--brand), var(--brand-2), var(--brand));
        box-shadow: 0 8px 18px rgba(63,180,255,0.35);
      }
      .subtle{color:var(--muted)}

      /* Card */
      .card{
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border:1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding:16px;
        position: relative;
        overflow: hidden;
      }
      .card h2, .card h3{margin:0 0 10px 0; font-size:16px}
      .card::before{
        content:""; position:absolute; inset: 0; pointer-events:none;
        background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.00)); opacity:.25;
      }
      .card:hover{
        box-shadow: 0 10px 30px rgba(0,0,0,0.45);
        transform: translateY(-1px);
        transition: transform .12s ease, box-shadow .2s ease;
      }

      /* Utility layout helpers */
      .row{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
      .stack{display:flex; flex-direction:column; gap:8px}
      .spaced{display:flex; align-items:center; justify-content:space-between; gap:12px}
      .muted{color:var(--muted)}
      .help{font-size:12px; color:var(--muted); margin-top:6px}

      /* Inputs & buttons */
      select, input[type="number"], input[type="text"], input[type="search"]{
        background-color: var(--field-bg); color:var(--field-text);
        border:1px solid var(--border);
        border-radius:10px; padding:8px 10px; outline:none;
        transition: border-color .2s ease, background-color .2s ease, color .2s ease;
      }
      select:focus, input:focus{border-color: var(--brand)}
      select option{
        background-color: var(--field-bg);
        color: var(--field-text);
      }
      button{
        appearance:none; border:1px solid var(--border); color:var(--text);
        background: linear-gradient(180deg, #1a1d25, #0f1218);
        border-radius: 12px; padding:8px 12px; cursor:pointer;
        transition: transform .06s ease, border-color .2s ease, background .2s ease;
      }
      button:hover{transform: translateY(-1px); border-color: var(--brand)}
      button:disabled{ opacity:.55; cursor:not-allowed; filter:saturate(.7); }
      .btn-primary{ background: linear-gradient(180deg, var(--brand), var(--brand-2)); color:#041018; border-color: transparent; font-weight:600; }
      .btn-ghost{ background: transparent; }
      .btn-icon { display:inline-flex; align-items:center; gap:8px; }
      .btn-icon svg{ width:16px; height:16px; opacity:.9 }
      .btn-primary.btn-icon svg{ opacity:.95 }
      .status{
        padding: 6px 10px; border-radius:999px; font-size:12px;
        border:1px solid var(--border); background: rgba(255,255,255,0.03);
      }

      /* Level meter + VAD */
      #levelMeter{ width: 280px; height: 12px; background: rgba(255,255,255,0.06); border-radius: 999px; position:relative; overflow:hidden; border:1px solid var(--border);}
      #levelBar{ width:0%; height:100%; background: linear-gradient(90deg, #7fd, #0c9); transition: width 120ms linear; }
      #vadDot{ width:12px; height:12px; border-radius:999px; background:#bbb; box-shadow: inset 0 0 0 2px rgba(0,0,0,0.15); }

      /* Log + transcripts */
      #speechLog, #transcriptBox{
        max-height: 220px; overflow:auto; padding:10px;
        border:1px solid var(--border); border-radius:12px; background: rgba(0,0,0,0.12);
        line-height:1.35;
      }
      #speechLog em, #transcriptBox em{color:var(--muted)}
      .utt { margin:4px 0; display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:8px; }
      .utt:hover{ background: rgba(255,255,255,0.04); }
      .utt time { color:var(--muted); font-size:11px; margin-right:8px; min-width:92px; text-align:right; opacity:.75 }
      .utt small { color:var(--muted); font-size:11px; margin-left:8px }

      /* Confidence badge for Whisper confidence */
      .badge { display:inline-block; padding:2px 10px; border-radius:999px; font-size:11px; border:1px solid var(--border); margin-left:8px; letter-spacing: .2px;}
      .badge-hi   { background: rgba(38,162,105,0.17); color: var(--ok); }
      .badge-mid  { background: rgba(234,179,8,0.17);  color: #eab308; }
      .badge-low  { background: rgba(192,28,40,0.17);  color: var(--bad); }

      /* Grid placement */
      .col-span-2{grid-column: 1 / -1}
      .devices{grid-column: 1 / -1}
      .audio{grid-column: 1 / 2}
      .vad{grid-column: 2 / 3}
      .transcripts{grid-column: 1 / -1}

      @media (max-width: 920px){
        .container{grid-template-columns: 1fr}
        .audio, .vad, .devices, .transcripts{grid-column: 1 / -1}
      }

      /* Toasts (little notifications in bottom-right) */
      .toast{
        min-width: 220px;
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border:1px solid var(--border);
        border-radius: 12px;
        padding:10px 12px;
        box-shadow: var(--shadow);
        color: var(--text);
        animation: toastIn .18s ease-out forwards;
      }
      .toast.ok    { border-color: rgba(38,162,105,.35); }
      .toast.warn  { border-color: rgba(234,179,8,.35);  }
      .toast.error { border-color: rgba(192,28,40,.35); }
      @keyframes toastIn { from{opacity:0; transform: translateY(6px)} to{opacity:1; transform: translateY(0)} }
      @keyframes toastOut{ to{ opacity:0; transform: translateY(6px)} }

      @media (prefers-reduced-motion: reduce){
        *{ transition:none !important; animation:none !important }
      }

      input[type="checkbox"]{ width:16px; height:16px; accent-color: var(--brand-2); }
    </style>
  </head>

  <body>
    <div class="container">
      <!-- =================================================================== -->
      <!-- Header (app title + quick worker ping)                              -->
      <!-- =================================================================== -->
      <header>
        <div class="brand">
          <div class="logo"></div>
          <div>
            <div style="font-weight:700">AI Assistant</div>
            <div class="subtle" style="font-size:12px">Desktop capture · Whisper · Notes</div>
          </div>
        </div>
        <div class="row">
          <button id="themeToggle" type="button" class="btn-ghost" title="Toggle light or dark mode">Toggle theme</button>
          <span id="appVersionBadge" class="status muted" title="Application version">v?.?.?</span>
          <span class="muted">Worker:</span>
          <span id="workerStatus" class="status muted">Checking…</span>
        </div>
      </header>

      <!-- =================================================================== -->
      <!-- Meeting Controls                                                     -->
      <!-- Create → Start → Stop; we persist the active meeting id locally.    -->
      <!-- =================================================================== -->
      <section class="card" id="meetingCard" style="grid-column: 1 / -1">
        <div class="spaced">
          <h2>Meeting</h2>
          <span class="status muted" id="meetingStatus">No active meeting</span>
        </div>

        <div class="row" style="margin-top:8px">
          <input id="meetingTitleInput" placeholder="e.g., Client – Living Room Consult" style="width:300px" />
          <button id="newMeetingBtn" class="btn-primary btn-icon" title="Create a new meeting">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            New
          </button>
          <button id="startMeetingBtn" class="btn-ghost btn-icon" title="Set active meeting">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="6,4 20,12 6,20 6,4"/></svg>
            Start
          </button>
          <button id="stopMeetingBtn" class="btn-ghost btn-icon" title="Clear active meeting">
            <svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
            Stop
          </button>
        </div>

        <!-- Existing meetings selector -->
        <div class="row" style="margin-top:8px">
          <label class="stack" style="min-width:320px">
            <span class="muted">Select existing meeting</span>
            <select id="meetingSelect"></select>
          </label>
          <button id="refreshMeetingListBtn" class="btn-ghost btn-icon" title="Refresh meeting list">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-2.64-6.36"/><polyline points="21 3 21 9 15 9"/></svg>
            Refresh
          </button>
          <button id="loadFullBtn" class="btn-ghost btn-icon" title="Load full transcript into view">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8M8 12h8M8 18h8"/></svg>
            Load Full Transcript
          </button>
          <button id="deleteMeetingBtn" class="btn-ghost btn-icon" title="Delete selected meeting and its transcripts">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>
            Delete
          </button>
        </div>

        <!-- Export + speaker labeling controls (collapsible) -->
        <details class="collapsible" style="margin-top:12px">
          <summary class="muted" style="cursor:pointer">Export & Speaker Options</summary>
          <div class="stack" style="margin-top:10px">
            <div class="row" style="gap:12px; align-items:center">
              <label class="row" style="gap:8px">
                <span class="muted">Speaker labels</span>
                <select id="speakersMode">
                  <option value="0">None</option>
                  <option value="heuristic">Heuristic</option>
                  <option value="auto">Auto (embeddings)</option>
                </select>
              </label>
              <label class="row" style="gap:8px">
                <span class="muted">Max speakers</span>
                <input type="number" id="maxSpeakers" min="1" max="20" placeholder="e.g., 5" style="width:80px" />
              </label>

              <button id="exportJsonBtn" class="btn-ghost btn-icon" title="Open JSON export in a new tab">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16v16H4z"/><path d="M8 8h8v8H8z"/></svg>
                Export JSON
              </button>
              <button id="exportMdBtn" class="btn-ghost btn-icon" title="Open Markdown export in a new tab">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16v16H4z"/><path d="M7 12h10M7 8h10M7 16h6"/></svg>
                Export MD
              </button>
            </div>
            <div class="help">Exports use the current meeting and optional speaker mode.</div>
          </div>
        </details>

        <!-- Summary controls (kept prominent) -->
        <div class="row" style="gap:12px; align-items:center; margin-top:10px">
          <button id="openSummaryBtn" class="btn-ghost btn-icon" title="Open quick summary preview">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20v-6m0-4V4"/><circle cx="12" cy="12" r="9"/></svg>
            Summary
          </button>
          <button id="exportNotesMdBtn" class="btn-ghost btn-icon" title="Open notes (Markdown) in a new tab">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16v16H4z"/><path d="M7 8h10M7 12h10M7 16h6"/></svg>
            Notes MD
          </button>
          <button id="saveNotesBtn" class="btn-ghost btn-icon" title="Save notes to exports/ as Markdown">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            Save Notes
          </button>
          <button id="saveDocxBtn" class="btn-ghost btn-icon" title="Save notes to exports/ as DOCX">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16v16H4z"/><path d="M7 8h5M7 12h8M7 16h10"/></svg>
            Save DOCX
          </button>
          <label class="row" style="gap:6px; margin-left:8px" title="Use stricter rewrite to avoid verbatim quotes">
            <input type="checkbox" id="summaryStrictToggle" />
            <span class="muted">Strict rewrite</span>
          </label>
          <button id="regenSummaryBtn" class="btn-ghost btn-icon" title="Regenerate notes (recompute via model)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12a9 9 0 1 1-2.64-6.36"/><polyline points="21 3 21 9 15 9"/></svg>
            Regenerate
          </button>
        </div>

        <div class="help" id="meetingHelp">Create a meeting, then click Start to make it active. Utterances will attach automatically.</div>
      </section>

      <!-- =================================================================== -->
      <!-- Device pickers (playback + mic)                                     -->
      <!-- On Windows, loopback from speakers will grab system audio.          -->
      <!-- =================================================================== -->
      <section class="card devices">
        <h2>Audio Devices</h2>
        <div class="row">
          <label class="stack" style="min-width:260px">
            <span class="muted">Playback (Speakers for loopback on Windows)</span>
            <select id="playbackSelect"></select>
          </label>
          <label class="stack" style="min-width:260px">
            <span class="muted">Microphone (optional)</span>
            <select id="micSelect"></select>
          </label>
          <div class="row">
            <button id="refreshDevices" class="btn-ghost btn-icon">
              <!-- refresh icon -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12a9 9 0 1 1-2.64-6.36"/><polyline points="21 3 21 9 15 9"/>
              </svg>
              Refresh
            </button>
          </div>
          <span id="deviceHelp" class="help">—</span>
        </div>
      </section>

      <!-- =================================================================== -->
      <!-- Capture controls + live level meter                                 -->
      <!-- =================================================================== -->
      <section class="card audio">
        <div class="spaced">
          <h2>Capture</h2>
          <div class="row">
            <button id="startBtn" class="btn-primary btn-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="6,4 20,12 6,20 6,4"></polygon>
              </svg>
              Start
            </button>
            <button id="stopBtn" class="btn-ghost btn-icon">
              <svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
              Stop
            </button>
            <span id="capStatus" class="status muted">Stopped</span>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div id="levelMeter"><div id="levelBar"></div></div>
          <span id="levelLabel" class="muted">Level: (waiting) | ~dB: —</span>
        </div>

          <div class="row" style="margin-top:12px">
          <button id="manualTranscribeBtn" class="btn-ghost">Transcribe last 10s</button>
          <span id="manualTrStatus" class="muted"></span>
        </div>
      </section>

      <!-- =================================================================== -->
      <!-- Voice Activity + event log + preferences (noise gate, VAD, autoTR)  -->
      <!-- =================================================================== -->
      <section class="card vad">
        <h2>Voice Activity</h2>
        <div class="row" style="margin-top:4px">
          <div id="vadDot"></div>
          <span id="vadLabel" class="muted">Speech: (idle)</span>
        </div>

        <details class="collapsible" style="margin-top:12px">
          <summary class="muted" style="cursor:pointer">Advanced: VAD Log & Preferences</summary>
          <div class="stack" style="margin-top:10px">
            <strong>Speech events</strong>
            <div class="row">
              <button id="clearLogBtn" class="btn-ghost">Clear</button>
            </div>
            <div id="speechLog"><em>Waiting…</em></div>
          </div>

          <div class="stack" style="margin-top:14px">
            <h3>Preferences</h3>
            <div class="row">
              <label class="row" style="gap:8px">
                <span class="muted">Noise Gate (dB)</span>
                <input type="number" id="noiseGateInput" step="1" style="width:80px" />
              </label>
              <label class="row" style="gap:8px">
                <span class="muted">VAD Aggressiveness</span>
                <select id="vadAggSelect">
                  <option value="0">0 (permissive)</option>
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3 (strict)</option>
                </select>
              </label>
              <label class="row" style="gap:8px">
                <input type="checkbox" id="autoTrToggle" checked />
                <span class="muted">Auto transcribe on speech end</span>
              </label>
              <label class="row" style="gap:8px">
                <span class="muted">Auto window (s)</span>
                <input type="number" id="autoTrSecondsInput" min="5" max="180" step="5" style="width:80px" />
              </label>
              <label class="row" style="gap:8px">
                <span class="muted">Silence hangover (ms)</span>
                <input type="number" id="hangoverInput" min="500" max="8000" step="100" style="width:100px" />
              </label>
            </div>
            <span class="help">Values are saved locally and sent to the worker.</span>
          </div>
        </details>
      </section>

      <!-- =================================================================== -->
      <!-- Transcript list (meeting-aware)                                     -->
      <!-- =================================================================== -->
      <section class="card transcripts col-span-2">
        <div class="spaced">
          <h2>Transcripts</h2>
        </div>
        <div id="transcriptBox" style="margin-top:10px"><em>No transcripts yet.</em></div>
      </section>
    </div>

    <!-- Toast host (absolute positioned notification area) -->
    <div id="toastHost" style="position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:8px; z-index:9999;"></div>

    <!-- ===================================================================== -->
    <!-- App script: everything below is plain DOM + fetch to the worker API.  -->
    <!-- Keep IDs stable so we can iterate without breaking.                   -->
    <!-- ===================================================================== -->
    <script>
      // ---------------------------------------------------------------------
      // Theme toggle (light / dark) with local persistence
      // ---------------------------------------------------------------------
      const themeToggleBtn = document.getElementById('themeToggle');
      const themeStorageKey = 'ui.theme';
      let currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';

      function setTheme(theme, { persist = true } = {}) {
        const normalized = theme === 'light' ? 'light' : 'dark';
        currentTheme = normalized;
        document.documentElement.setAttribute('data-theme', normalized);
        if (persist) {
          try {
            localStorage.setItem(themeStorageKey, normalized);
          } catch (_) {
            /* ignore storage failures */
          }
        }
        if (themeToggleBtn) {
          const label = normalized === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
          themeToggleBtn.textContent = label;
          themeToggleBtn.setAttribute('aria-label', label);
        }
      }

      // Sync initial toggle label without re-persisting
      setTheme(currentTheme, { persist: false });

      if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', () => {
          const next = currentTheme === 'dark' ? 'light' : 'dark';
          setTheme(next);
        });
      }

      const systemThemeMedia = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
      if (systemThemeMedia) {
        const handleSchemeChange = (event) => {
          try {
            if (localStorage.getItem(themeStorageKey)) return; // respect manual selection
          } catch (_) {
            /* ignore access issues */
          }
          setTheme(event.matches ? 'dark' : 'light', { persist: false });
        };
        if (typeof systemThemeMedia.addEventListener === 'function') {
          systemThemeMedia.addEventListener('change', handleSchemeChange);
        } else if (typeof systemThemeMedia.addListener === 'function') {
          systemThemeMedia.addListener(handleSchemeChange);
        }
      }

      const appVersionBadge = document.getElementById('appVersionBadge');
      let appVersion = '?.?.?';
      let logFileHint = null;
      if (window.appInfo && typeof window.appInfo.subscribe === 'function') {
        window.appInfo.subscribe(info => {
          if (info && typeof info.version === 'string') {
            appVersion = info.version;
            if (appVersionBadge) {
              appVersionBadge.textContent = `v${appVersion}`;
              appVersionBadge.title = `Application version ${appVersion}`;
            }
          }
          if (info && typeof info.logPath === 'string') {
            logFileHint = info.logPath;
            if (appVersionBadge) {
              appVersionBadge.dataset.logPath = logFileHint;
              appVersionBadge.title = `Version ${appVersion} • Logs: ${logFileHint}`;
            }
          }
        });
      }

      // ---------------------------------------------------------------------
      // Small helpers
      // ---------------------------------------------------------------------
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      /** Show a small toast message (ok|warn|error). */
      function toast(msg, kind='ok', ms=2400){
        const host = document.getElementById('toastHost');
        const div = document.createElement('div');
        div.className = `toast ${kind}`;
        div.textContent = msg;
        host.appendChild(div);
        setTimeout(()=>{
          div.style.animation = 'toastOut .15s ease-in forwards';
          setTimeout(()=>host.removeChild(div), 180);
        }, ms);
      }

      /** Return an id from payload regardless of whether backend uses `id` or `meeting_id`. */
      function getIdFlexible(obj){
        if (!obj || typeof obj !== 'object') return null;
        return obj.meeting_id ?? obj.id ?? null;
      }

      // ---------------------------------------------------------------------
      // Preferences (noise gate / VAD / auto-transcribe)
      // Stored in localStorage so they persist across app launches.
      // ---------------------------------------------------------------------
      const noiseGateInput = document.getElementById('noiseGateInput');
      const vadAggSelect   = document.getElementById('vadAggSelect');
      const autoTrToggle   = document.getElementById('autoTrToggle');
      const autoTrSecondsInput = document.getElementById('autoTrSecondsInput');
      const hangoverInput  = document.getElementById('hangoverInput');

      async function sendAutoConfig({ enable, windowSec, hangoverMs } = {}){
        const body = {};
        if (typeof enable === 'boolean') body.auto_transcribe = enable;
        if (typeof windowSec === 'number') body.auto_window_s = windowSec;
        if (typeof hangoverMs === 'number') body.vad_hangover_ms = hangoverMs;
        try{
          await fetch('http://127.0.0.1:8000/v1/auto_config', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
        } catch (e) { console.warn('auto_config failed', e); }
      }

      /** Load preferences from localStorage or init defaults. */
      function loadPreferences() {
        let ng = localStorage.getItem('noiseGateDb');
        let vad = localStorage.getItem('vadAgg');
        let autoTr = localStorage.getItem('autoTr') ?? '1'; // default ON
        let autoTrSec = parseInt(localStorage.getItem('autoTrSec') || '180', 10);
        if (!Number.isFinite(autoTrSec)) autoTrSec = 180;
        autoTrSec = Math.max(5, Math.min(180, autoTrSec));
        let hangMs = parseInt(localStorage.getItem('vadHangoverMs') || '1000', 10);
        if (!Number.isFinite(hangMs)) hangMs = 1000;
        hangMs = Math.max(500, Math.min(8000, hangMs));

        if (ng === null || ng === '') { ng = '-40'; localStorage.setItem('noiseGateDb', ng); }
        if (vad === null || vad === '') { vad = '2';   localStorage.setItem('vadAgg', vad); }

        noiseGateInput.value = ng;
        vadAggSelect.value = vad;
        autoTrToggle.checked = autoTr === '1';
        if (autoTrSecondsInput) autoTrSecondsInput.value = String(autoTrSec);
        if (hangoverInput) hangoverInput.value = String(hangMs);
        // Reflect chosen seconds in manual button label
        const manualBtnEl = document.getElementById('manualTranscribeBtn');
        if (manualBtnEl) manualBtnEl.textContent = `Transcribe last ${autoTrSec}s`;
        // Inform backend: backend will handle auto-transcribe on speech end
        sendAutoConfig({ enable: autoTrToggle.checked, windowSec: autoTrSec, hangoverMs: hangMs }).catch(()=>{});
      }
      // Persist changes
      noiseGateInput.addEventListener('change', () => localStorage.setItem('noiseGateDb', noiseGateInput.value));
      vadAggSelect.addEventListener('change', () => localStorage.setItem('vadAgg', vadAggSelect.value));
      autoTrToggle.addEventListener('change', () => {
        localStorage.setItem('autoTr', autoTrToggle.checked ? '1' : '0');
        const v = parseInt(localStorage.getItem('autoTrSec') || '180', 10);
        const secs = Math.max(5, Math.min(180, Number.isFinite(v) ? v : 180));
        const h = parseInt(localStorage.getItem('vadHangoverMs') || '1000', 10);
        const hang = Math.max(500, Math.min(8000, Number.isFinite(h) ? h : 1000));
        sendAutoConfig({ enable: autoTrToggle.checked, windowSec: secs, hangoverMs: hang }).catch(()=>{});
      });
      autoTrSecondsInput.addEventListener('change', () => {
        let v = parseInt(autoTrSecondsInput.value || '180', 10);
        if (!Number.isFinite(v)) v = 180;
        v = Math.max(5, Math.min(180, v));
        autoTrSecondsInput.value = String(v);
        localStorage.setItem('autoTrSec', String(v));
        const h = parseInt(localStorage.getItem('vadHangoverMs') || '1000', 10);
        const hang = Math.max(500, Math.min(8000, Number.isFinite(h) ? h : 1000));
        sendAutoConfig({ enable: autoTrToggle.checked, windowSec: v, hangoverMs: hang }).catch(()=>{});
        const manualBtnEl = document.getElementById('manualTranscribeBtn');
        if (manualBtnEl) manualBtnEl.textContent = `Transcribe last ${v}s`;
      });
      hangoverInput.addEventListener('change', () => {
        let h = parseInt(hangoverInput.value || '1000', 10);
        if (!Number.isFinite(h)) h = 1000;
        h = Math.max(500, Math.min(8000, h));
        hangoverInput.value = String(h);
        localStorage.setItem('vadHangoverMs', String(h));
        const v = parseInt(localStorage.getItem('autoTrSec') || '180', 10);
        const secs = Math.max(5, Math.min(180, Number.isFinite(v) ? v : 180));
        sendAutoConfig({ enable: autoTrToggle.checked, windowSec: secs, hangoverMs: h }).catch(()=>{});
      });

      // ---------------------------------------------------------------------
      // Worker health (simple GET /health + retry loop on boot)
      // ---------------------------------------------------------------------
      const workerStatus = document.getElementById("workerStatus");

      /** One-shot worker health check. */
      async function checkHealthOnce() {
        const res = await fetch("http://127.0.0.1:8000/health");
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        return data?.status === "ok";
      }
      /** Retry a few times during boot so the UI doesn't race worker start. */
      async function waitForWorkerOnline({ tries = 20, delayMs = 250 } = {}) {
        for (let i = 0; i < tries; i++) {
          try { if (await checkHealthOnce()) return true; } catch (_) {}
          await sleep(delayMs);
        }
        return false;
      }
      // Update header status periodically
      async function updateWorkerStatus(){
        try{
          const ok = await checkHealthOnce();
          if(workerStatus){ workerStatus.textContent = ok ? 'Online' : 'Offline'; workerStatus.style.color = ok ? 'var(--ok)' : 'var(--bad)'; }
        }catch{
          if(workerStatus){ workerStatus.textContent = 'Offline'; workerStatus.style.color = 'var(--bad)'; }
        }
      }

      // ---------------------------------------------------------------------
      // Meeting state & helpers
      // We keep the active meeting id in localStorage so refreshes are safe.
      // Endpoints used:
      //   POST /meeting/new               body: {title}
      //   POST /meeting/start/{id}
      //   POST /meeting/stop
      // ---------------------------------------------------------------------
      let activeMeetingId = null;
      let serverMeetingId = null;  // server-reported active meeting
      const meetingMetaById = Object.create(null); // { id: {created_at, title} }

      function meetingDisplayLabel(id, meta, { whenMissingId = 'none', whenMissingMeta = 'selected' } = {}) {
        if (id === null || id === undefined) return whenMissingId;
        const title = (meta?.title || '').trim();
        if (title) return title;
        const createdAt = (meta?.created_at || '').trim();
        if (createdAt) return createdAt;
        if (typeof id === 'number' && Number.isFinite(id)) return `#${id}`;
        const asStr = String(id || '').trim();
        if (asStr) return asStr;
        return whenMissingMeta;
      }

      function resetTranscriptViewFor(meetingId) {
        sinceIdByMeeting[meetingId || 0] = 0;
        transcriptBox.innerHTML = '<em>No transcripts yet.</em>';
      }
      /** Save active id to memory + localStorage, refresh status, reset sinceId. */
      function saveActiveMeetingId(id) {
        activeMeetingId = id ?? null;
        if (activeMeetingId === null) {
          localStorage.removeItem('activeMeetingId');
        } else {
          localStorage.setItem('activeMeetingId', String(activeMeetingId));
          // reset delta state whenever the meeting changes
          resetTranscriptViewFor(activeMeetingId);
          // restart polling so we fetch for the new meeting immediately
          restartTranscriptPolling();
        }
        updateMeetingStatusUI();
      }

      /** Load active id from localStorage at boot. */
      function loadActiveMeetingId() {
        const v = localStorage.getItem('activeMeetingId');
        activeMeetingId = v ? Number(v) : null;
        updateMeetingStatusUI();
      }

      /** Update the header badge inside the Meeting card (shows client + server). */
      function updateMeetingStatusUI() {
        const el = document.getElementById('meetingStatus');
        if (!el) return;
        const clientMeta = activeMeetingId ? meetingMetaById[activeMeetingId] : null;
        const clientTxt = meetingDisplayLabel(
          activeMeetingId,
          clientMeta,
          { whenMissingId: 'none', whenMissingMeta: 'selected' }
        );
        const hasServerId = serverMeetingId !== null && serverMeetingId !== undefined;
        const serverMeta = hasServerId && serverMeetingId ? meetingMetaById[serverMeetingId] : null;
        let serverTxt;
        if (!hasServerId) {
          serverTxt = '…';
        } else if (serverMeetingId === 0) {
          serverTxt = 'none';
        } else {
          serverTxt = meetingDisplayLabel(
            serverMeetingId,
            serverMeta,
            { whenMissingId: 'none', whenMissingMeta: 'selected' }
          );
        }
        const mismatch = !!(activeMeetingId && serverMeetingId && activeMeetingId !== serverMeetingId);
        el.textContent = `Active: ${clientTxt} (server: ${serverTxt}${mismatch ? ' !' : ''})`;
        if (activeMeetingId) el.classList.remove('muted'); else el.classList.add('muted');
        if (mismatch) { el.style.color = '#eab308'; } else { el.style.color = ''; }
      }

      // Wire meeting buttons
      const newMeetingBtn   = document.getElementById('newMeetingBtn');
      const startMeetingBtn = document.getElementById('startMeetingBtn');
      const stopMeetingBtn  = document.getElementById('stopMeetingBtn');
      const meetingTitleInp = document.getElementById('meetingTitleInput');
      const meetingSelect   = document.getElementById('meetingSelect');
      const refreshMeetingListBtn = document.getElementById('refreshMeetingListBtn');
      const loadFullBtn = document.getElementById('loadFullBtn');
      const deleteMeetingBtn = document.getElementById('deleteMeetingBtn');

      function labelForMeeting(it){
        const dt = (it && it.created_at) ? String(it.created_at) : '';
        const title = (it && it.title) ? String(it.title) : 'Untitled';
        return dt ? `${dt} — ${title}` : title;
      }

      async function fetchMeetingList() {
        try {
          const r = await fetch('http://127.0.0.1:8000/v1/meetings?limit=200');
          if (!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          if (!j?.ok || !Array.isArray(j.items)) throw new Error('Bad response');
          // Populate select
          meetingSelect.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = '(select a meeting)';
          meetingSelect.appendChild(placeholder);
          j.items.forEach(it => {
            const createdAt = typeof it.created_at === 'string' ? it.created_at.trim() : '';
            const title = typeof it.title === 'string' ? it.title.trim() : '';
            meetingMetaById[it.id] = { created_at: createdAt, title };
            const opt = document.createElement('option');
            opt.value = String(it.id);
            opt.textContent = labelForMeeting(it);
            if (activeMeetingId && Number(activeMeetingId) === Number(it.id)) opt.selected = true;
            meetingSelect.appendChild(opt);
          });
        } catch (e) {
          console.error('fetchMeetingList failed:', e);
          toast('Failed to load meetings: ' + e.message, 'error');
        }
      }

      refreshMeetingListBtn?.addEventListener('click', () => { fetchMeetingList().catch(()=>{}); });
      // Lazy-load meetings when user focuses the dropdown and it's empty
      meetingSelect?.addEventListener('focus', () => {
        try {
          if (!meetingSelect || meetingSelect.options.length <= 1) {
            fetchMeetingList().catch(()=>{});
          }
        } catch {}
      });
      meetingSelect?.addEventListener('change', () => {
        const val = meetingSelect.value;
        if (val === '') return;
        const id = Number(val);
        if (!Number.isFinite(id)) return;
        saveActiveMeetingId(id);
      });
      // Selecting in dropdown immediately sets active meeting

      deleteMeetingBtn?.addEventListener('click', async () => {
        const val = meetingSelect && meetingSelect.value;
        const id = val ? Number(val) : (activeMeetingId || null);
        if (!id) { toast('Select a meeting first', 'warn'); return; }
        const label = meetingDisplayLabel(
          id,
          meetingMetaById[id],
          { whenMissingId: `#${id}`, whenMissingMeta: `#${id}` }
        );
        const ok = confirm(`Delete meeting (${label}) and all its transcripts? This cannot be undone.`);
        if (!ok) return;
        try {
          const r = await fetch(`http://127.0.0.1:8000/v1/meeting/${id}`, { method:'DELETE' });
          if (!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          if (!j.ok || !j.deleted_meeting) throw new Error('Delete failed');
          if (activeMeetingId === id) {
            saveActiveMeetingId(null);
            transcriptBox.innerHTML = '<em>No transcripts yet.</em>';
          }
          toast(`Deleted meeting (${label})`, 'ok');
          await fetchMeetingList();
          updateMeetingStatusUI();
        } catch (e) {
          console.error(e);
          toast('Delete failed: ' + e.message, 'error');
        }
      });

      loadFullBtn?.addEventListener('click', async () => {
        if (!ensureMeetingOrToast()) return;
        try {
          const q = buildSpeakerQuery(); // reuse speaker params if provided (ignored for now)
          const url = `http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/export.json` + (q ? `?${q}` : '');
          const r = await fetch(url);
          if (!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          if (!j?.meeting || !Array.isArray(j.utterances)) throw new Error('Bad payload');
          // Clear and render all utterances
          transcriptBox.innerHTML = '';
          let lastId = 0;
          j.utterances.forEach(u => {
            appendTranscriptItem({ id: u.id, ts_iso: u.ts_iso, text: u.text });
            if (u.id && u.id > lastId) lastId = u.id;
          });
          sinceIdByMeeting[activeMeetingId] = lastId;
          toast('Loaded full transcript', 'ok');
        } catch (e) {
          console.error(e);
          toast('Load full failed: ' + e.message, 'error');
        }
      });

      newMeetingBtn?.addEventListener('click', async () => {
        const title = (meetingTitleInp?.value || '').trim();
        if (!title) {
          toast('Enter a meeting title first', 'warn');
          meetingTitleInp?.focus();
          return;
        }
        try {
          const r = await fetch(`http://127.0.0.1:8000/v1/meeting/new?title=${encodeURIComponent(title)}`, { method:'POST' });
          if (!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          console.debug("[/meeting/new] response:", j);

          // FLEXIBLE: accept either {meeting_id} or {id}
          const id = getIdFlexible(j);
          if (!j?.ok || id === null || id === undefined) throw new Error('No id returned');

          const createdAtResp = j?.meeting?.created_at ?? j?.created_at ?? meetingMetaById[id]?.created_at ?? '';
          const titleResp = j?.meeting?.title ?? j?.title ?? title;
          meetingMetaById[id] = {
            created_at: typeof createdAtResp === 'string' ? createdAtResp.trim() : '',
            title: typeof titleResp === 'string' ? titleResp.trim() : ''
          };

          saveActiveMeetingId(id);     // Make it the current meeting in the UI
          if (transcriptBox) transcriptBox.innerHTML = '<em>No transcripts yet.</em>';
          if (activeMeetingId) sinceIdByMeeting[activeMeetingId] = 0;
          restartTranscriptPolling();  // refresh list for the (new) meeting
          refreshServerMeetingStatus().catch(()=>{});
          const label = meetingDisplayLabel(
            id,
            meetingMetaById[id],
            { whenMissingId: 'New meeting', whenMissingMeta: 'New meeting' }
          );
          toast(`Created meeting: ${label}`);
          // Refresh meeting list so the new one appears in the dropdown
          fetchMeetingList().catch(()=>{});
        } catch (e) {
          console.error(e);
          toast('Create failed: ' + e.message, 'error');
        }
      });

      startMeetingBtn?.addEventListener('click', async () => {
        if (!activeMeetingId) {
          toast('No meeting selected. Create a meeting first.', 'warn');
          return;
        }
        try {
          const r = await fetch(`http://127.0.0.1:8000/v1/meeting/start/${activeMeetingId}`, { method:'POST' });
          if (!r.ok) throw new Error('HTTP '+r.status);
          await r.json();
          toast('Started meeting');
          serverMeetingId = activeMeetingId; updateMeetingStatusUI();
          if (transcriptBox) transcriptBox.innerHTML = '<em>No transcripts yet.</em>';
          if (activeMeetingId) sinceIdByMeeting[activeMeetingId] = 0;
          restartTranscriptPolling(); // now that a meeting is active, start fetching its utterances
        } catch (e) {
          console.error(e);
          toast('Start failed: ' + e.message, 'error');
        }
      });

      stopMeetingBtn?.addEventListener('click', async () => {
        try {
          const r = await fetch('http://127.0.0.1:8000/v1/meeting/stop', { method:'POST' });
          if (!r.ok) throw new Error('HTTP '+r.status);
          await r.json();
          toast('Stopped active meeting');
        } catch (e) {
          console.error(e);
          toast('Stop failed: ' + e.message, 'error');
        } finally {
          // We keep activeMeetingId in localStorage (user can START again),
          // but we pause transcript polling because the meeting is stopped.
          stopTranscriptPolling();
          serverMeetingId = null; updateMeetingStatusUI();
        }
      });

      // Fetch server active meeting id and update UI
      async function refreshServerMeetingStatus(){
        try{
          const r = await fetch('http://127.0.0.1:8000/v1/meeting/active');
          if(!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          serverMeetingId = (typeof j.id === 'number') ? j.id : (j.id ? Number(j.id) : null);
        }catch{ serverMeetingId = null; }
        updateMeetingStatusUI();
      }

      // ---------------------------------------------------------------------
      // ---------------------------------------------------------------------
      // Export handlers (JSON / MD / Summary) with optional speaker mode
      // ---------------------------------------------------------------------
      const speakersModeSel = document.getElementById('speakersMode');
      const maxSpeakersInp  = document.getElementById('maxSpeakers');
      const exportJsonBtn   = document.getElementById('exportJsonBtn');
      const exportMdBtn     = document.getElementById('exportMdBtn');
      const openSummaryBtn  = document.getElementById('openSummaryBtn');
      const exportNotesMdBtn= document.getElementById('exportNotesMdBtn');
      const saveNotesBtn    = document.getElementById('saveNotesBtn');
      const saveDocxBtn     = document.getElementById('saveDocxBtn');
      const summaryStrictToggle = document.getElementById('summaryStrictToggle');
      const regenSummaryBtn = document.getElementById('regenSummaryBtn');

      function buildSpeakerQuery() {
        const mode = (speakersModeSel?.value || '0');
        const maxS = (maxSpeakersInp?.value || '').trim();
        const params = new URLSearchParams();
        if (mode && mode !== '0') params.set('speakers', mode);
        if (maxS) params.set('max_speakers', String(Math.max(1, Math.min(20, Number(maxS)))));
        return params.toString();
      }

      function ensureMeetingOrToast() {
        if (!activeMeetingId) {
          toast('No active meeting. Create & Start one first.', 'warn');
          return false;
        }
        return true;
      }

      exportJsonBtn?.addEventListener('click', () => {
        if (!ensureMeetingOrToast()) return;
        const q = buildSpeakerQuery();
        const url = `http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/export.json` + (q ? `?${q}` : '');
        window.open(url, '_blank', 'noopener,noreferrer');
      });

      exportMdBtn?.addEventListener('click', () => {
        if (!ensureMeetingOrToast()) return;
        const q = buildSpeakerQuery();
        const url = `http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/export.md` + (q ? `?${q}` : '');
        window.open(url, '_blank', 'noopener,noreferrer');
      });

      openSummaryBtn?.addEventListener('click', () => {
        if (!ensureMeetingOrToast()) return;
        const strict = summaryStrictToggle && summaryStrictToggle.checked ? '1' : '0';
        const bust = Date.now();
        const url = `http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/summary?strict=${strict}&_=${bust}`; // cached unless missing
        window.open(url, '_blank', 'noopener,noreferrer');
      });

      exportNotesMdBtn?.addEventListener('click', () => {
        if (!ensureMeetingOrToast()) return;
        const strict = summaryStrictToggle && summaryStrictToggle.checked ? '1' : '0';
        const bust = Date.now();
        const url = `http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/summary.md?strict=${strict}&_=${bust}`; // cached unless missing
        window.open(url, '_blank', 'noopener,noreferrer');
      });

      saveNotesBtn?.addEventListener('click', async () => {
        if (!ensureMeetingOrToast()) return;
        const strict = summaryStrictToggle && summaryStrictToggle.checked ? '1' : '0';
        try{
          const r = await fetch(`http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/export_notes?strict=${strict}`, { method:'POST' });
          if(!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          if (!j.ok) throw new Error(j.error || 'save failed');
          if (j.path && window.api?.revealPath) { try { await window.api.revealPath(j.path); } catch {}
          }
          toast(`Saved: ${j.filename}`, 'ok');
        }catch(e){ toast(`Save failed: ${e.message}`, 'error'); }
      });

      saveDocxBtn?.addEventListener('click', async () => {
        if (!ensureMeetingOrToast()) return;
        const strict = summaryStrictToggle && summaryStrictToggle.checked ? '1' : '0';
        try{
          const r = await fetch(`http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/export_notes_docx?strict=${strict}`, { method:'POST' });
          if(!r.ok) throw new Error('HTTP '+r.status);
          const j = await r.json();
          if (!j.ok) throw new Error(j.error || 'save failed');
          if (j.path && window.api?.revealPath) { try { await window.api.revealPath(j.path); } catch {}
          }
          toast(`Saved: ${j.filename}`, 'ok');
        }catch(e){ toast(`DOCX save failed: ${e.message}`, 'error'); }
      });

      regenSummaryBtn?.addEventListener('click', () => {
        if (!ensureMeetingOrToast()) return;
        const strict = summaryStrictToggle && summaryStrictToggle.checked ? '1' : '0';
        const bust = Date.now();
        const url = `http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/summary?strict=${strict}&regen=1&_=${bust}`; // force recompute
        window.open(url, '_blank', 'noopener,noreferrer');
      });

      // ---------------------------------------------------------------------
      // Devices (GET /devices) with helpful macOS/Windows tip text
      // ---------------------------------------------------------------------
      const playbackSelect = document.getElementById("playbackSelect");
      const micSelect = document.getElementById("micSelect");
      const deviceHelp = document.getElementById("deviceHelp");
      const refreshBtn = document.getElementById("refreshDevices");

      async function loadDevicesOnce() {
        const res = await fetch("http://127.0.0.1:8000/v1/devices");
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        playbackSelect.innerHTML = "";
        micSelect.innerHTML = "";

        // Placeholders so user can leave playback empty and choose mic explicitly
        const pbNone = document.createElement('option');
        pbNone.value = '';
        pbNone.textContent = 'None (no loopback)';
        playbackSelect.appendChild(pbNone);

        const micPlaceholder = document.createElement('option');
        micPlaceholder.value = '';
        micPlaceholder.textContent = 'Select input…';
        micSelect.appendChild(micPlaceholder);

        const simpleLabels = (data.os === "Windows_NT" || data.os === "Windows");

        for (const d of data.outputs) {
          const opt = document.createElement("option");
          opt.value = String(d.id);
          let label = simpleLabels ? d.name : `${d.name} [${d.hostapi}]`;
          if (d.is_loopback && !label.toLowerCase().includes("loopback")) {
            label += " (loopback)";
          }
          opt.textContent = label;
          playbackSelect.appendChild(opt);
        }
        for (const d of data.inputs) {
          const opt = document.createElement("option");
          opt.value = String(d.id);
          opt.textContent = simpleLabels ? d.name : `${d.name} [${d.hostapi}]`;
          micSelect.appendChild(opt);
        }

        const defaults = (data && data.defaults) || {};
        const applyDefault = (selectEl, value) => {
          if (value === null || value === undefined) return false;
          const val = String(value);
          for (const opt of selectEl.options) {
            if (opt.value === val) {
              selectEl.value = val;
              return true;
            }
          }
          return false;
        };
        const hasOutputDefault = applyDefault(playbackSelect, defaults.output);
        const hasInputDefault = applyDefault(micSelect, defaults.input);
        if (!hasOutputDefault && playbackSelect.options.length > 1) {
          playbackSelect.selectedIndex = 1;
        }
        if (!hasInputDefault && micSelect.options.length > 1) {
          micSelect.selectedIndex = 1;
        }

        deviceHelp.textContent = (data.os === "Windows_NT" || data.os === "Windows")
          ? "Tip: choose your Speakers (WASAPI) for loopback capture. Mic is optional."
          : "On macOS, loopback requires a virtual device. Mic works for development.";
      }

      async function loadDevicesWithRetry({ tries = 5, delayMs = 500 } = {}) {
        deviceHelp.textContent = "Loading devices…";
        for (let i = 0; i < tries; i++) {
          try { await loadDevicesOnce(); return; }
          catch (e) {
            console.warn("loadDevices attempt failed:", e.message);
            if (i < tries - 1) await sleep(delayMs);
            else deviceHelp.textContent = "Could not load devices.";
          }
        }
      }
      refreshBtn.addEventListener("click", () => loadDevicesWithRetry());

      // ---------------------------------------------------------------------
      // Capture controls (start/stop) + live level meter (GET /level)
      // ---------------------------------------------------------------------
      const startBtn = document.getElementById("startBtn");
      const stopBtn  = document.getElementById("stopBtn");
      const capStatus = document.getElementById("capStatus");

      function setRunButtons(running){
        startBtn.disabled = running;
        stopBtn.disabled  = !running;
        startBtn.style.opacity = running ? .55 : 1;
        stopBtn.style.opacity  = !running ? .55 : 1;
        startBtn.style.cursor  = running ? 'not-allowed' : 'pointer';
        stopBtn.style.cursor   = !running ? 'not-allowed' : 'pointer';
      }
      function styleCapStatus(running){
        const el = document.getElementById('capStatus');
        el.style.color = running ? 'var(--ok)' : 'var(--muted)';
      }

      /** Ask backend if capture is running, then update button state + label. */
      async function refreshCaptureStatus() {
        try {
          const r = await fetch("http://127.0.0.1:8000/v1/capture_status");
          if (!r.ok) throw new Error("HTTP " + r.status);
          const j = await r.json();
          captureRunning = !!j.running;
          capStatus.textContent = captureRunning ? "Capturing…" : "Stopped";
          setRunButtons(captureRunning);
          styleCapStatus(captureRunning);
          return captureRunning;
        } catch (e) {
          capStatus.textContent = "Status error";
          console.error(e);
          return false;
        }
      }

      // Level meter helpers
      let smoothedRms = 0; const SMOOTH_ALPHA = 0.3;
      function rmsToDb(r){ const eps=1e-8; return 20*Math.log10(Math.max(r,eps)); }
      function rmsToPercent(r){ const db=rmsToDb(r), min=-60,max=0; return Math.max(0,Math.min(100,((db-min)/(max-min))*100)); }
      function updateLevelUI(rms, running){
        const bar=document.getElementById("levelBar"); const label=document.getElementById("levelLabel");
        smoothedRms = SMOOTH_ALPHA*rms + (1-SMOOTH_ALPHA)*smoothedRms;
        const pct = rmsToPercent(smoothedRms); const db = rmsToDb(smoothedRms);
        bar.style.width = `${pct.toFixed(0)}%`;
        label.textContent = running ? `Level: ${smoothedRms.toFixed(4)} (${pct.toFixed(0)}%) | ~dB: ${db.toFixed(1)}`
                                    : "Level: stopped | ~dB: —";
      }
      let levelTimer=null;
      async function pollLevelOnce(){
        const r=await fetch("http://127.0.0.1:8000/v1/level");
        if(!r.ok) throw new Error('HTTP '+r.status);
        const j=await r.json();
        updateLevelUI(j.rms||0, !!j.running);
      }
      function startLevelPolling(){ if(levelTimer) return; pollLevelOnce().catch(()=>{}); levelTimer=setInterval(()=>{ pollLevelOnce().catch(()=>{}); },200); }
      function stopLevelPolling(){ if(levelTimer){ clearInterval(levelTimer); levelTimer=null; } updateLevelUI(0,false); }

      // ---------------------------------------------------------------------
      // Voice Activity + event log + auto-transcribe trigger
      // Endpoint: GET /vad_check?ng=-40&vad=3
      // ---------------------------------------------------------------------
      const vadLabel=document.getElementById('vadLabel');
      const vadDot=document.getElementById('vadDot');
      const logBox=document.getElementById('speechLog');
      const clearLogBtn=document.getElementById('clearLogBtn');

      function setVadUI({speech, running}){
        if(!running){ vadDot.style.background='#bbb'; vadLabel.textContent='Speech: (stopped)'; return; }
        if(speech){ vadDot.style.background='var(--ok)'; vadLabel.textContent='Speech: yes'; }
        else { vadDot.style.background='var(--bad)'; vadLabel.textContent='Speech: no'; }
      }
      function logMsg(text){
        const at=new Date(), ts=at.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
        const div=document.createElement('div'); div.textContent=`[${ts}] ${text}`;
        if(logBox.firstElementChild && logBox.firstElementChild.tagName==='EM') logBox.innerHTML='';
        logBox.appendChild(div); logBox.scrollTop=logBox.scrollHeight;
      }
      clearLogBtn.addEventListener('click', ()=>{ logBox.innerHTML='<em>Cleared</em>'; });

      let vadTimer=null, lastStableSpeech=null;
      let autoTrCooldown = false;   // short cooldown after transcribe
      let autoTrBusy = false;       // avoid concurrent auto runs

      /** Poll VAD and trigger auto-transcribe when speech → silence. */
      async function pollVadOnce(){
        const ng=noiseGateInput.value||-40, vad=vadAggSelect.value||3;
        const r=await fetch(`http://127.0.0.1:8000/v1/vad_check?ng=${encodeURIComponent(ng)}&vad=${encodeURIComponent(vad)}`);
        if(!r.ok) throw new Error('HTTP '+r.status);
        const j=await r.json();
        setVadUI({speech:!!j.speech, running:!!j.running});
        if(j.running){
          if(lastStableSpeech===null){
            lastStableSpeech=!!j.speech;
            if(lastStableSpeech) logMsg('Speech started');
          } else if(!!j.speech!==lastStableSpeech){
            lastStableSpeech=!!j.speech;
            logMsg(lastStableSpeech?'Speech started':'Speech ended');
            // Backend-only auto-transcribe: UI does not trigger here
          }
        } else {
          lastStableSpeech=null;
        }
      }
      function startVadPolling(){ if(vadTimer) return; pollVadOnce().catch(()=>{}); vadTimer=setInterval(()=>{ pollVadOnce().catch(()=>{}); },100); }
      function stopVadPolling(){ if(vadTimer){ clearInterval(vadTimer); vadTimer=null; } setVadUI({speech:false, running:false}); lastStableSpeech=null; }

      // ----- Transcripts (MEETING-AWARE) — adaptive polling to reduce spam -----
      const transcriptBox = document.getElementById('transcriptBox');
      const sinceIdByMeeting = Object.create(null);
      let trTimer = null;        // handle for setTimeout loop
      let pollMs = 1500;         // adaptive interval (ms)
      let idleRounds = 0;        // consecutive empty polls
      let lastRenderedIds = "";  // simple fingerprint to detect changes
      let captureRunning = false; // updated by refreshCaptureStatus()

      /** Small badge with color per confidence bucket. */
      function confBadge(conf) {
        if (typeof conf !== 'number') return null;
        let cls = 'badge-mid';
        if (conf >= 0.75) cls = 'badge-hi';
        else if (conf < 0.5) cls = 'badge-low';
        const b = document.createElement('span');
        b.className = `badge ${cls}`;
        b.textContent = `conf ${(conf*100).toFixed(0)}%`;
        return b;
      }

      /** Render a single utterance row (one line). */
      function appendTranscriptItem(t){
        const div=document.createElement('div'); div.className='utt';
        const tm=document.createElement('time'); tm.textContent=`[${t.ts_iso}]`;
        const span=document.createElement('span'); span.textContent=t.text;
        const meta=document.createElement('small'); meta.textContent=`(${t.filename || '—'})`;
        div.appendChild(tm);
        div.appendChild(span);
        const b = confBadge(t.confidence); if (b) div.appendChild(b);
        div.appendChild(meta);
        if (transcriptBox.firstElementChild && transcriptBox.firstElementChild.tagName==='EM') {
          transcriptBox.innerHTML='';
        }
        transcriptBox.appendChild(div);
        transcriptBox.scrollTop=transcriptBox.scrollHeight;
      }

      /** Poll only new rows for the current meeting and append them. */
      async function pollTranscriptsOnce(){
        if (!activeMeetingId) return;

        const currentSince = sinceIdByMeeting[activeMeetingId] ?? 0;
        const r = await fetch(`http://127.0.0.1:8000/v1/meeting/${activeMeetingId}/utterances?since_id=${currentSince}&limit=200`);
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const j = await r.json();

        // Append new items (already ASC order)
        if (Array.isArray(j.items) && j.items.length) {
          j.items.forEach(appendTranscriptItem);
        }

        // Bump since_id so next poll is delta-only
        if (typeof j.next_since_id === 'number') {
          sinceIdByMeeting[activeMeetingId] = j.next_since_id;
        }
        // Adaptive interval: fast when capturing or new items; otherwise backoff up to 8s
        const gotNew = Array.isArray(j.items) && j.items.length > 0;
        if (captureRunning || gotNew) { pollMs = 1500; idleRounds = 0; }
        else { idleRounds = Math.min(idleRounds + 1, 10); pollMs = Math.min(1500 + idleRounds*650, 8000); }
      }

      function startTranscriptPolling(){
        if (trTimer) return;
        const loop = async () => {
          trTimer = null;
          if (document.hidden) { trTimer = setTimeout(loop, 2500); return; }
          try { await pollTranscriptsOnce(); } catch {}
          trTimer = setTimeout(loop, pollMs);
        };
        loop();
      }
      function stopTranscriptPolling(){ if (trTimer){ clearTimeout(trTimer); trTimer = null; } }
      function restartTranscriptPolling(){ stopTranscriptPolling(); startTranscriptPolling(); }
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) restartTranscriptPolling(); });
      
      // ---------------------------------------------------------------------
      // Auto-transcribe helper
      // Simple 2-step: dump last N seconds → transcribe → refresh list
      // ---------------------------------------------------------------------
      async function autoTranscribeLast(seconds = 180){
        if (autoTrBusy || autoTrCooldown) return;
        autoTrBusy = true;
        try{
          const r1 = await fetch(`http://127.0.0.1:8000/v1/dump_wav?seconds=${seconds}&label=auto`);
          if (!r1.ok) throw new Error('dump failed');
          const j1 = await r1.json();
          if (!j1.ok) throw new Error(j1.message || 'dump failed');

          const r2 = await fetch(`http://127.0.0.1:8000/v1/transcribe_wav?path=${encodeURIComponent(j1.filename)}&language=en${activeMeetingId?`&meeting_id=${activeMeetingId}`:''}`);
          const j2 = await r2.json();
          if (!r2.ok || !j2.ok) throw new Error((j2 && j2.error) ? j2.error : 'transcribe failed');
          await pollTranscriptsOnce();   // refresh UI immediately
          toast(`Auto-transcribed ${j1.filename}`, 'ok');
        } catch (e) {
          console.error(e);
          toast(`Auto-transcribe error: ${e.message}`, 'error');
        } finally {
          autoTrBusy = false;
          autoTrCooldown = true;
          setTimeout(()=>{ autoTrCooldown = false; }, 1200);
        }
      }

      // ---------------------------------------------------------------------
      // Manual transcribe button
      // ---------------------------------------------------------------------

      const manualBtn=document.getElementById('manualTranscribeBtn');
      const manualLabel=document.getElementById('manualTrStatus');
      manualBtn.addEventListener('click', async ()=>{
        manualLabel.textContent='Working…';
        try{
          // Use configured auto window seconds for manual transcribes too
          const v = parseInt((autoTrSecondsInput && autoTrSecondsInput.value) ? autoTrSecondsInput.value : (localStorage.getItem('autoTrSec') || '180'), 10);
          const secs = Math.max(5, Math.min(180, Number.isFinite(v) ? v : 180));
          const r1=await fetch(`http://127.0.0.1:8000/v1/dump_wav?seconds=${secs}&label=manual`); if(!r1.ok) throw new Error('dump failed');
          const j1=await r1.json(); if(!j1.ok) throw new Error(j1.message||'dump failed');
          const r2=await fetch(`http://127.0.0.1:8000/v1/transcribe_wav?path=${encodeURIComponent(j1.filename)}&language=en${activeMeetingId?`&meeting_id=${activeMeetingId}`:''}`);
          const j2=await r2.json(); if(!r2.ok || !j2.ok) throw new Error((j2 && j2.error) ? j2.error : 'transcribe failed');
          manualLabel.textContent=`Saved + transcribed: ${j1.filename}`;
          toast(`Transcribed ${j1.filename}`, 'ok');
          await pollTranscriptsOnce();
        }catch(e){ console.error(e); manualLabel.textContent='Failed: '+e.message; toast(`Error: ${e.message}`, 'error'); }
      });

      // Echo demo removed for a cleaner UI

      // ---------------------------------------------------------------------
      // Boot sequence
      // - load prefs + previously active meeting id
      // - wait for worker
      // - load devices + capture status
      // - start meeting-aware transcript polling (no-op if no meeting yet)
      // ---------------------------------------------------------------------
      (async function boot(){
        loadPreferences();
        loadActiveMeetingId();                 // meeting id from localStorage
        await refreshServerMeetingStatus();    // show server status early
        const online=await waitForWorkerOnline();
        if(online){
          await updateWorkerStatus();
          // Load meetings now that worker is online
          await fetchMeetingList().catch(()=>{});
          // Re-send auto config now that worker is online
          try {
            const v = parseInt(localStorage.getItem('autoTrSec') || '180', 10);
            const secs = Math.max(5, Math.min(180, Number.isFinite(v) ? v : 180));
            const h = parseInt(localStorage.getItem('vadHangoverMs') || '1000', 10);
            const hang = Math.max(500, Math.min(8000, Number.isFinite(h) ? h : 1000));
            await sendAutoConfig({ enable: document.getElementById('autoTrToggle').checked, windowSec: secs, hangoverMs: hang });
          } catch {}
          await loadDevicesWithRetry();
          await refreshCaptureStatus();
          startTranscriptPolling();            // will only render if activeMeetingId is set
        }else{
          if(workerStatus){ workerStatus.textContent='Offline'; workerStatus.style.color='var(--bad)'; }
          deviceHelp.textContent="Worker not ready. Try Refresh devices.";
        }
        // Light polling to keep server status badge fresh
        setInterval(()=>{ refreshServerMeetingStatus().catch(()=>{}); updateWorkerStatus().catch(()=>{}); }, 5000);
      })();

      // Hook capture start/stop to backend + begin/stop polling loops
      startBtn.addEventListener("click", async ()=>{
        capStatus.textContent="Starting…";
        try{
          // Ensure server has the same active meeting as the UI
          if (activeMeetingId) {
            try { await fetch(`http://127.0.0.1:8000/v1/meeting/start/${activeMeetingId}`, { method:'POST' }); } catch {}
            serverMeetingId = activeMeetingId; updateMeetingStatusUI();
          }
          const body={
            playback_id: (playbackSelect.value === '' ? null : Number(playbackSelect.value)),
            mic_id: (micSelect.value === '' ? null : Number(micSelect.value)),
            samplerate:48000
          };
          const r=await fetch("http://127.0.0.1:8000/v1/start_capture",{
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body:JSON.stringify(body)
          });
          if(!r.ok) throw new Error("HTTP "+r.status);
          await r.json();
          await refreshCaptureStatus();
          startLevelPolling();
          startVadPolling();
        }catch(e){
          capStatus.textContent="Start error";
          console.error(e);
          toast(`Error: ${e.message}`, 'error');
        }
      });

      stopBtn.addEventListener("click", async ()=>{
        capStatus.textContent="Stopping…";
        try{ await fetch("http://127.0.0.1:8000/v1/stop_capture",{ method:"POST" }); }catch{}
        stopLevelPolling();
        stopVadPolling();
        await refreshCaptureStatus();
      });
    </script>
  </body>
</html>
